https://github.com/BillyKlebitz/FT_Containers/wiki/

https://stackoverflow.com/questions/3582608/how-to-correctly-implement-custom-iterators-and-const-iterators

https://stackoverflow.com/questions/4622330/operator-overloading-member-function-vs-non-member-function


std::iterator_traits<Iterator> are just a way to access any needed types (value type, pointer type, reference type, difference type) from a given iterator without knowing the data structure it belongs to neither the template parameter (eg. int vector, float vector etc., just use std::iterator_traits<myVector>::value_type)
specializations are in the case where there is no iterators but only a plain pointer (eg int* / T*), where the value_type is put as int/T, pointer as int*/T*, and so on
when saying the container must implement the iterator_traits, it should just contain the necessary typedefs (value_type, difference_type etc. which should be accessible by using myContainer::value_type ...)

Since "myContainer::iterator" is always a typedef of some other iterator (forward / bidirectional / random etc.) it could also be a typedef of just int* (pointer of int) and the caller (an algorithm for instance) doesn't know and doesn't have to know it, this is the reason why
there is a pointer specialization in iterator_traits, because as said above, even if it's not a real iterator, it would still work

If multiple templates could fit like this:

template <typename T>
void	somePouet(typename T::value someValue) {}

template <typename T>
void	somePouet(typename T::otherValue someOtherValue) {}

struct Test1
{
	typedef int	value;
};

struct Test2
{
	typedef int	value;
	typedef int	otherValue;
};

int main()
{
	somePouet<Test2>(0);
}

if we call somePouet with Test1 it would use the first one, but with Test2 it could use both, here the compiler issues an error "Call is ambiguous"

SNIFAE:
https://www.youtube.com/watch?v=mNxAqLVIaW0

Basically if a template does not match (substitution failure) other ones will be tried out before throwing an error
It's an error only if there isn't any other matching templates, see snifae_example.cpp
